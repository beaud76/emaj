-- startStop.sql : test emaj_start_group(), emaj_start_groups(), emaj_stop_group() and emaj_stop_groups()functions
--
-- prepare groups
select emaj.emaj_create_group('myGroup1');
NOTICE:  table "myschema1_myTbl3_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS "emajC"."myschema1_myTbl3_log""
PL/pgSQL function "_create_tbl" line 83 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  trigger "myschema1_myTbl3_emaj_log_trg" for table "myTbl3" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS "myschema1_myTbl3_emaj_log_trg" ON myschema1."myTbl3""
PL/pgSQL function "_create_tbl" line 148 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  table "myschema1_mytbl1_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema1_mytbl1_log"
PL/pgSQL function "_create_tbl" line 83 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  trigger "myschema1_mytbl1_emaj_log_trg" for table "mytbl1" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl1_emaj_log_trg ON myschema1.mytbl1"
PL/pgSQL function "_create_tbl" line 148 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  table "myschema1_mytbl4_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema1_mytbl4_log"
PL/pgSQL function "_create_tbl" line 83 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  trigger "myschema1_mytbl4_emaj_log_trg" for table "mytbl4" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl4_emaj_log_trg ON myschema1.mytbl4"
PL/pgSQL function "_create_tbl" line 148 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  table "myschema1_mytbl2_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema1_mytbl2_log"
PL/pgSQL function "_create_tbl" line 83 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  trigger "myschema1_mytbl2_emaj_log_trg" for table "mytbl2" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl2_emaj_log_trg ON myschema1.mytbl2"
PL/pgSQL function "_create_tbl" line 148 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
WARNING:  _create_tbl: table myschema1.mytbl2 has triggers (mytbl2trg). Verify the compatibility with emaj rollback operations (in particular if triggers update one or several other tables). Triggers may have to be manualy disabled before rollback.
CONTEXT:  SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  table "myschema1_mytbl2b_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emajb.myschema1_mytbl2b_log"
PL/pgSQL function "_create_tbl" line 83 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  trigger "myschema1_mytbl2b_emaj_log_trg" for table "mytbl2b" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl2b_emaj_log_trg ON myschema1.mytbl2b"
PL/pgSQL function "_create_tbl" line 148 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
 emaj_create_group 
-------------------
                 6
(1 row)

select emaj.emaj_create_group('myGroup2');
NOTICE:  table "myschema2_mytbl1_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema2_mytbl1_log"
PL/pgSQL function "_create_tbl" line 83 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  trigger "myschema2_mytbl1_emaj_log_trg" for table "mytbl1" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl1_emaj_log_trg ON myschema2.mytbl1"
PL/pgSQL function "_create_tbl" line 148 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  table "myschema2_mytbl2_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema2_mytbl2_log"
PL/pgSQL function "_create_tbl" line 83 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  trigger "myschema2_mytbl2_emaj_log_trg" for table "mytbl2" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl2_emaj_log_trg ON myschema2.mytbl2"
PL/pgSQL function "_create_tbl" line 148 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  table "myschema2_myTbl3_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS "emajC"."myschema2_myTbl3_log""
PL/pgSQL function "_create_tbl" line 83 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  trigger "myschema2_myTbl3_emaj_log_trg" for table "myTbl3" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS "myschema2_myTbl3_emaj_log_trg" ON myschema2."myTbl3""
PL/pgSQL function "_create_tbl" line 148 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  table "myschema2_mytbl4_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema2_mytbl4_log"
PL/pgSQL function "_create_tbl" line 83 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  trigger "myschema2_mytbl4_emaj_log_trg" for table "mytbl4" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl4_emaj_log_trg ON myschema2.mytbl4"
PL/pgSQL function "_create_tbl" line 148 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  table "myschema2_mytbl5_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema2_mytbl5_log"
PL/pgSQL function "_create_tbl" line 83 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  trigger "myschema2_mytbl5_emaj_log_trg" for table "mytbl5" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl5_emaj_log_trg ON myschema2.mytbl5"
PL/pgSQL function "_create_tbl" line 148 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  table "myschema2_mytbl6_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema2_mytbl6_log"
PL/pgSQL function "_create_tbl" line 83 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
NOTICE:  trigger "myschema2_mytbl6_emaj_log_trg" for table "mytbl6" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl6_emaj_log_trg ON myschema2.mytbl6"
PL/pgSQL function "_create_tbl" line 148 at EXECUTE statement
SQL statement "SELECT  emaj._create_tbl( $1 ,  $2 ,  $3 , coalesce( $4 ,  $5 ), coalesce( $6 ,  $5 ),  $7 )"
PL/pgSQL function "emaj_create_group" line 90 at PERFORM
PL/pgSQL function "emaj_create_group" line 6 at RETURN
 emaj_create_group 
-------------------
                 8
(1 row)

INSERT INTO emaj.emaj_param (param_key, param_value_interval) VALUES ('history_retention','1 second'::interval);
select pg_sleep(1);
 pg_sleep 
----------
 
(1 row)

-----------------------------
-- emaj_start_group() tests
-----------------------------
-- group is unknown in emaj_group_def
select emaj.emaj_start_group(NULL,NULL);
ERROR:  _start_group: group <NULL> has not been created.
CONTEXT:  SQL statement "SELECT emaj._start_groups(array[ $1 ],  $2 , false,  $3 )"
PL/pgSQL function "emaj_start_group" line 16 at SQL statement
PL/pgSQL function "emaj_start_group" line 5 at RETURN
select emaj.emaj_start_group('unknownGroup',NULL,NULL);
ERROR:  _start_group: group unknownGroup has not been created.
CONTEXT:  SQL statement "SELECT emaj._start_groups(array[ $1 ],  $2 , false,  $3 )"
PL/pgSQL function "emaj_start_group" line 16 at SQL statement
-- reserved mark name
select emaj.emaj_start_group('myGroup1','EMAJ_LAST_MARK');
ERROR:  _check_new_mark: EMAJ_LAST_MARK is not an allowed name for a new mark.
CONTEXT:  SQL statement "SELECT emaj._check_new_mark( $1 ,  $2 )"
PL/pgSQL function "_start_groups" line 48 at SQL statement
SQL statement "SELECT emaj._start_groups(array[ $1 ],  $2 , false,  $3 )"
PL/pgSQL function "emaj_start_group" line 16 at SQL statement
PL/pgSQL function "emaj_start_group" line 5 at RETURN
-- missing application table
begin;
  drop table mySchema2."myTbl3" cascade;
  select emaj.emaj_start_group('myGroup2','M1');
ERROR:  _verify_group: Checking tables group myGroup2: table/sequence myschema2.myTbl3 does not exist anymore.
CONTEXT:  SQL statement "SELECT  0 FROM emaj._verify_group( $1 [ $2 ], true)"
PL/pgSQL function "_start_groups" line 36 at PERFORM
SQL statement "SELECT emaj._start_groups(array[ $1 ],  $2 , false,  $3 )"
PL/pgSQL function "emaj_start_group" line 16 at SQL statement
PL/pgSQL function "emaj_start_group" line 5 at RETURN
rollback;
-- should be OK
select emaj.emaj_start_group('myGroup1','Mark1');
 emaj_start_group 
------------------
                6
(1 row)

select emaj.emaj_start_group('myGroup2','Mark2',true);
 emaj_start_group 
------------------
                8
(1 row)

select emaj.emaj_start_group('phil''s group#3",','Mark3',false);
 emaj_start_group 
------------------
                3
(1 row)

select emaj.emaj_stop_group('myGroup1');
 emaj_stop_group 
-----------------
               6
(1 row)

select emaj.emaj_stop_group('myGroup2');
 emaj_stop_group 
-----------------
               8
(1 row)

-- should be OK, with a warning on fkey between tables from different groups
begin;
  alter table myschema2.myTbl4 drop constraint mytbl4_col44_fkey;
  alter table myschema2.myTbl4 add constraint mytbl4_col44_fkey 
    FOREIGN KEY (col44,col45) REFERENCES myschema1.myTbl1 (col11,col12) ON DELETE CASCADE ON UPDATE SET NULL;
  select emaj.emaj_start_group('myGroup2','Mark2');
WARNING:  _check_fk_groups: Foreign key mytbl4_col44_fkey, from table myschema2.mytbl4, references myschema1.mytbl1 that is outside groups (myGroup2).
CONTEXT:  SQL statement "SELECT  emaj._check_fk_groups(array[ $1 [ $2 ]])"
PL/pgSQL function "_start_groups" line 45 at PERFORM
SQL statement "SELECT emaj._start_groups(array[ $1 ],  $2 , false,  $3 )"
PL/pgSQL function "emaj_start_group" line 16 at SQL statement
PL/pgSQL function "emaj_start_group" line 5 at RETURN
 emaj_start_group 
------------------
                8
(1 row)

rollback;
-- start with generated mark name
select emaj.emaj_start_group('myGroup1','%abc%',true);
 emaj_start_group 
------------------
                6
(1 row)

select emaj.emaj_start_group('myGroup2','',false);
 emaj_start_group 
------------------
                8
(1 row)

-- group already started
select emaj.emaj_start_group('myGroup2','Mark3');
ERROR:  _start_group: The group myGroup2 cannot be started because it is not in idle state. An emaj_stop_group function must be previously executed.
CONTEXT:  SQL statement "SELECT emaj._start_groups(array[ $1 ],  $2 , false,  $3 )"
PL/pgSQL function "emaj_start_group" line 16 at SQL statement
PL/pgSQL function "emaj_start_group" line 5 at RETURN
-- check how truncate reacts  - tables are empty anyway
-- ... for a rollbackable group (must be blocked in pg 8.4+)
truncate myschema1.mytbl1 cascade;
NOTICE:  truncate cascades to table "mytbl4"
-- ... for an audit_only group (must be logged in pg 8.4+)
truncate "phil's schema3"."phil's tbl1" cascade;
NOTICE:  truncate cascades to table "mytbl4"
NOTICE:  truncate cascades to table "myTbl2\"
select "phil's col11", "phil's col12", "phil\s col13", 
       emaj_verb, emaj_tuple, emaj_gid, emaj_user, emaj_user_ip 
  from "emaj #'3"."phil's schema3_phil's tbl1_log";
 phil's col11 | phil's col12 | phil\s col13 | emaj_verb | emaj_tuple | emaj_gid | emaj_user | emaj_user_ip 
--------------+--------------+--------------+-----------+------------+----------+-----------+--------------
(0 rows)

-- impact of started group
select group_name, group_state, group_nb_table, group_nb_sequence, group_comment 
  from emaj.emaj_group order by group_name, group_state;
    group_name    | group_state | group_nb_table | group_nb_sequence | group_comment 
------------------+-------------+----------------+-------------------+---------------
 myGroup1         | LOGGING     |              5 |                 1 | 
 myGroup2         | LOGGING     |              6 |                 2 | 
 phil's group#3", | LOGGING     |              2 |                 1 | 
(3 rows)

select mark_id, mark_group, regexp_replace(mark_name,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'), mark_global_seq, mark_state, mark_comment, mark_last_seq_hole_id, mark_last_sequence_id, mark_log_rows_before_next from emaj.emaj_mark order by mark_id;
 mark_id |    mark_group    | regexp_replace | mark_global_seq | mark_state | mark_comment | mark_last_seq_hole_id | mark_last_sequence_id | mark_log_rows_before_next 
---------+------------------+----------------+-----------------+------------+--------------+-----------------------+-----------------------+---------------------------
       5 | myGroup2         | Mark2          |               0 | DELETED    |              |                     0 |                    32 |                         0
       6 | phil's group#3", | Mark3          |               0 | ACTIVE     |              |                     0 |                    35 |                          
       8 | myGroup2         | STOP_%         |               0 | DELETED    |              |                     0 |                    49 |                          
      10 | myGroup1         | %abc%          |               0 | ACTIVE     |              |                     0 |                    63 |                          
      11 | myGroup2         | MARK_%         |               0 | ACTIVE     |              |                     0 |                    71 |                          
(5 rows)

-- check old events are deleted
select hist_function, hist_event, hist_object, regexp_replace(regexp_replace(hist_wording,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'),E'\\[.+\\]','(timestamp)','g'), hist_user from emaj.emaj_hist order by hist_id;
 hist_function  | hist_event |   hist_object    |         regexp_replace         | hist_user 
----------------+------------+------------------+--------------------------------+-----------
 START_GROUP    | BEGIN      | myGroup1         | With log reset                 | postgres
 LOCK_GROUP     | BEGIN      | myGroup1         |                                | postgres
 LOCK_GROUP     | END        | myGroup1         | 5 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup1         | Mark1                          | postgres
 SET_MARK_GROUP | END        | myGroup1         | Mark1                          | postgres
 START_GROUP    | END        | myGroup1         | 6 tables/sequences processed   | postgres
 START_GROUP    | BEGIN      | myGroup2         | With log reset                 | postgres
 LOCK_GROUP     | BEGIN      | myGroup2         |                                | postgres
 LOCK_GROUP     | END        | myGroup2         | 6 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup2         | Mark2                          | postgres
 SET_MARK_GROUP | END        | myGroup2         | Mark2                          | postgres
 START_GROUP    | END        | myGroup2         | 8 tables/sequences processed   | postgres
 START_GROUP    | BEGIN      | phil's group#3", | Without log reset              | postgres
 LOCK_GROUP     | BEGIN      | phil's group#3", |                                | postgres
 LOCK_GROUP     | END        | phil's group#3", | 2 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | phil's group#3", | Mark3                          | postgres
 SET_MARK_GROUP | END        | phil's group#3", | Mark3                          | postgres
 START_GROUP    | END        | phil's group#3", | 3 tables/sequences processed   | postgres
 STOP_GROUP     | BEGIN      | myGroup1         |                                | postgres
 LOCK_GROUP     | BEGIN      | myGroup1         |                                | postgres
 LOCK_GROUP     | END        | myGroup1         | 5 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup1         | STOP_%                         | postgres
 SET_MARK_GROUP | END        | myGroup1         | STOP_%                         | postgres
 STOP_GROUP     | END        | myGroup1         | 6 tables/sequences processed   | postgres
 STOP_GROUP     | BEGIN      | myGroup2         |                                | postgres
 LOCK_GROUP     | BEGIN      | myGroup2         |                                | postgres
 LOCK_GROUP     | END        | myGroup2         | 6 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup2         | STOP_%                         | postgres
 SET_MARK_GROUP | END        | myGroup2         | STOP_%                         | postgres
 STOP_GROUP     | END        | myGroup2         | 8 tables/sequences processed   | postgres
 START_GROUP    | BEGIN      | myGroup1         | With log reset                 | postgres
 LOCK_GROUP     | BEGIN      | myGroup1         |                                | postgres
 LOCK_GROUP     | END        | myGroup1         | 5 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup1         | %abc%                          | postgres
 SET_MARK_GROUP | END        | myGroup1         | %abc%                          | postgres
 START_GROUP    | END        | myGroup1         | 6 tables/sequences processed   | postgres
 START_GROUP    | BEGIN      | myGroup2         | Without log reset              | postgres
 LOCK_GROUP     | BEGIN      | myGroup2         |                                | postgres
 LOCK_GROUP     | END        | myGroup2         | 6 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup2         | MARK_%                         | postgres
 SET_MARK_GROUP | END        | myGroup2         | MARK_%                         | postgres
 START_GROUP    | END        | myGroup2         | 8 tables/sequences processed   | postgres
(42 rows)

delete from emaj.emaj_param where param_key = 'history_retention';
-----------------------------
-- emaj_stop_group() tests
-----------------------------
-- unknown group
select emaj.emaj_stop_group(NULL);
ERROR:  _stop_group: group <NULL> has not been created.
CONTEXT:  PL/pgSQL function "emaj_stop_group" line 7 at RETURN
select emaj.emaj_stop_group('unkownGroup');
ERROR:  _stop_group: group unkownGroup has not been created.
CONTEXT:  PL/pgSQL function "emaj_stop_group" line 7 at RETURN
select emaj.emaj_stop_group(NULL,NULL);
ERROR:  _stop_group: group <NULL> has not been created.
CONTEXT:  PL/pgSQL function "emaj_stop_group" line 7 at RETURN
select emaj.emaj_stop_group('unkownGroup',NULL);
ERROR:  _stop_group: group unkownGroup has not been created.
CONTEXT:  PL/pgSQL function "emaj_stop_group" line 7 at RETURN
-- invalid mark
select emaj.emaj_stop_group('myGroup1','EMAJ_LAST_MARK');
ERROR:  _check_new_mark: EMAJ_LAST_MARK is not an allowed name for a new mark.
CONTEXT:  SQL statement "SELECT emaj._check_new_mark( $1 ,  $2 )"
PL/pgSQL function "_stop_groups" line 41 at SQL statement
PL/pgSQL function "emaj_stop_group" line 7 at RETURN
-- already existing mark
select emaj.emaj_stop_group('phil''s group#3",','Mark3');
ERROR:  _check_new_mark: Group phil's group#3", already contains a mark named Mark3.
CONTEXT:  SQL statement "SELECT emaj._check_new_mark( $1 ,  $2 )"
PL/pgSQL function "_stop_groups" line 41 at SQL statement
PL/pgSQL function "emaj_stop_group" line 7 at RETURN
-- missing application table
begin;
  drop table mySchema2."myTbl3" cascade;
  select emaj.emaj_stop_group('myGroup2');
ERROR:  relation "myschema2.myTbl3" does not exist
CONTEXT:  SQL statement "LOCK TABLE myschema2."myTbl3" IN ACCESS EXCLUSIVE MODE"
PL/pgSQL function "_lock_groups" line 34 at EXECUTE statement
SQL statement "SELECT  emaj._lock_groups( $1 ,'', $2 )"
PL/pgSQL function "_stop_groups" line 47 at PERFORM
PL/pgSQL function "emaj_stop_group" line 7 at RETURN
rollback;
-- should be OK
select emaj.emaj_stop_group('myGroup1');
 emaj_stop_group 
-----------------
               6
(1 row)

-- impact of stopped group
select group_name, group_state, group_nb_table, group_nb_sequence, group_comment 
  from emaj.emaj_group order by group_name, group_state;
    group_name    | group_state | group_nb_table | group_nb_sequence | group_comment 
------------------+-------------+----------------+-------------------+---------------
 myGroup1         | IDLE        |              5 |                 1 | 
 myGroup2         | LOGGING     |              6 |                 2 | 
 phil's group#3", | LOGGING     |              2 |                 1 | 
(3 rows)

select mark_id, mark_group, regexp_replace(mark_name,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'), mark_global_seq, mark_state, mark_comment, mark_last_seq_hole_id, mark_last_sequence_id, mark_log_rows_before_next from emaj.emaj_mark order by mark_id;
 mark_id |    mark_group    | regexp_replace | mark_global_seq | mark_state | mark_comment | mark_last_seq_hole_id | mark_last_sequence_id | mark_log_rows_before_next 
---------+------------------+----------------+-----------------+------------+--------------+-----------------------+-----------------------+---------------------------
       5 | myGroup2         | Mark2          |               0 | DELETED    |              |                     0 |                    32 |                         0
       6 | phil's group#3", | Mark3          |               0 | ACTIVE     |              |                     0 |                    35 |                          
       8 | myGroup2         | STOP_%         |               0 | DELETED    |              |                     0 |                    49 |                          
      10 | myGroup1         | %abc%          |               0 | DELETED    |              |                     0 |                    63 |                         0
      11 | myGroup2         | MARK_%         |               0 | ACTIVE     |              |                     0 |                    71 |                          
      12 | myGroup1         | STOP_%         |               0 | DELETED    |              |                     0 |                    77 |                          
(6 rows)

-- should be OK
select emaj.emaj_stop_group('myGroup2','Stop mark');
 emaj_stop_group 
-----------------
               8
(1 row)

-- warning, already stopped
select emaj.emaj_stop_group('myGroup2');
WARNING:  _stop_group: Group myGroup2 cannot be stopped because it is not in logging state.
CONTEXT:  PL/pgSQL function "emaj_stop_group" line 7 at RETURN
 emaj_stop_group 
-----------------
               0
(1 row)

select emaj.emaj_stop_group('myGroup2','Stop mark 2');
WARNING:  _stop_group: Group myGroup2 cannot be stopped because it is not in logging state.
CONTEXT:  PL/pgSQL function "emaj_stop_group" line 7 at RETURN
 emaj_stop_group 
-----------------
               0
(1 row)

-- start with auto-mark in a single transaction
begin transaction;
  select emaj.emaj_start_group('myGroup1',NULL);
 emaj_start_group 
------------------
                6
(1 row)

  select emaj.emaj_start_group('myGroup2','');
 emaj_start_group 
------------------
                8
(1 row)

commit;
select mark_id, mark_group, regexp_replace(mark_name,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'), mark_global_seq, mark_state, mark_comment, mark_last_seq_hole_id, mark_last_sequence_id, mark_log_rows_before_next from emaj.emaj_mark order by mark_id;
 mark_id |    mark_group    | regexp_replace | mark_global_seq | mark_state | mark_comment | mark_last_seq_hole_id | mark_last_sequence_id | mark_log_rows_before_next 
---------+------------------+----------------+-----------------+------------+--------------+-----------------------+-----------------------+---------------------------
       6 | phil's group#3", | Mark3          |               0 | ACTIVE     |              |                     0 |                    35 |                          
      14 | myGroup1         | MARK_%         |               0 | ACTIVE     |              |                     0 |                    91 |                          
      15 | myGroup2         | MARK_%         |               0 | ACTIVE     |              |                     0 |                    99 |                          
(3 rows)

begin transaction;
  select emaj.emaj_stop_group('myGroup1');
 emaj_stop_group 
-----------------
               6
(1 row)

  select emaj.emaj_stop_group('myGroup2');
 emaj_stop_group 
-----------------
               8
(1 row)

commit;
-- use of % in start mark name
select emaj.emaj_start_group('myGroup1','Foo%Bar');
 emaj_start_group 
------------------
                6
(1 row)

select mark_id, mark_group, regexp_replace(mark_name,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'), mark_global_seq, mark_state, mark_comment, mark_last_seq_hole_id, mark_last_sequence_id, mark_log_rows_before_next from emaj.emaj_mark order by mark_id;
 mark_id |    mark_group    | regexp_replace | mark_global_seq | mark_state | mark_comment | mark_last_seq_hole_id | mark_last_sequence_id | mark_log_rows_before_next 
---------+------------------+----------------+-----------------+------------+--------------+-----------------------+-----------------------+---------------------------
       6 | phil's group#3", | Mark3          |               0 | ACTIVE     |              |                     0 |                    35 |                          
      15 | myGroup2         | MARK_%         |               0 | DELETED    |              |                     0 |                    99 |                         0
      17 | myGroup2         | STOP_%         |               0 | DELETED    |              |                     0 |                   113 |                          
      18 | myGroup1         | Foo%Bar        |               0 | ACTIVE     |              |                     0 |                   119 |                          
(4 rows)

-----------------------------
-- emaj_start_groups() tests
-----------------------------
select emaj.emaj_stop_group('myGroup1');
 emaj_stop_group 
-----------------
               6
(1 row)

-- NULL group names array
select emaj.emaj_start_groups(NULL,NULL,NULL);
WARNING:  _check_group_names_array: No group name to process.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
 emaj_start_groups 
-------------------
                 0
(1 row)

-- at least one group is unknown in emaj_group_def
select emaj.emaj_start_groups('{""}',NULL);
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
PL/pgSQL function "emaj_start_groups" line 5 at RETURN
WARNING:  _check_group_names_array: No group name to process.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
PL/pgSQL function "emaj_start_groups" line 5 at RETURN
 emaj_start_groups 
-------------------
                 0
(1 row)

select emaj.emaj_start_groups('{"unknownGroup",""}',NULL,true);
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
ERROR:  _start_group: group unknownGroup has not been created.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
select emaj.emaj_start_groups('{"myGroup1","unknownGroup"}',NULL,false);
ERROR:  _start_group: group unknownGroup has not been created.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
-- reserved mark name
select emaj.emaj_start_groups('{"myGroup1"}','EMAJ_LAST_MARK');
ERROR:  _check_new_mark: EMAJ_LAST_MARK is not an allowed name for a new mark.
CONTEXT:  SQL statement "SELECT emaj._check_new_mark( $1 ,  $2 )"
PL/pgSQL function "_start_groups" line 48 at SQL statement
SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
PL/pgSQL function "emaj_start_groups" line 5 at RETURN
-- second group is already started
select emaj.emaj_start_group('myGroup2','Mark1',true);
 emaj_start_group 
------------------
                8
(1 row)

select emaj.emaj_start_groups('{"myGroup1","myGroup2"}','Mark1',false);
ERROR:  _start_group: The group myGroup2 cannot be started because it is not in idle state. An emaj_stop_group function must be previously executed.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
select emaj.emaj_stop_group('myGroup2');
 emaj_stop_group 
-----------------
               8
(1 row)

-- missing application table
begin;
  drop table mySchema2."myTbl3" cascade;
  select emaj.emaj_start_groups(array['myGroup1','myGroup2'],'Mark1',true);
ERROR:  _verify_group: Checking tables group myGroup2: table/sequence myschema2.myTbl3 does not exist anymore.
CONTEXT:  SQL statement "SELECT  0 FROM emaj._verify_group( $1 [ $2 ], true)"
PL/pgSQL function "_start_groups" line 36 at PERFORM
SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
rollback;
-- should be OK, with a warning on fkey between tables from different groups and warning on group names array content
begin;
  alter table myschema2.myTbl4 drop constraint mytbl4_col44_fkey;
  alter table myschema2.myTbl4 add constraint mytbl4_col44_fkey 
    FOREIGN KEY (col44,col45) REFERENCES myschema1.myTbl1 (col11,col12) ON DELETE CASCADE ON UPDATE SET NULL;
  select emaj.emaj_start_groups(array['myGroup1',NULL,'myGroup2','','myGroup2','myGroup2','myGroup1'],'Mark1');
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
PL/pgSQL function "emaj_start_groups" line 5 at RETURN
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
PL/pgSQL function "emaj_start_groups" line 5 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup2.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
PL/pgSQL function "emaj_start_groups" line 5 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup2.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
PL/pgSQL function "emaj_start_groups" line 5 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup1.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
PL/pgSQL function "emaj_start_groups" line 5 at RETURN
WARNING:  _check_fk_groups: table myschema1.mytbl1 is referenced by foreign key mytbl4_col44_fkey from table myschema2.mytbl4 that is outside groups (myGroup1).
CONTEXT:  SQL statement "SELECT  emaj._check_fk_groups(array[ $1 [ $2 ]])"
PL/pgSQL function "_start_groups" line 45 at PERFORM
SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
PL/pgSQL function "emaj_start_groups" line 5 at RETURN
WARNING:  _check_fk_groups: Foreign key mytbl4_col44_fkey, from table myschema2.mytbl4, references myschema1.mytbl1 that is outside groups (myGroup2).
CONTEXT:  SQL statement "SELECT  emaj._check_fk_groups(array[ $1 [ $2 ]])"
PL/pgSQL function "_start_groups" line 45 at PERFORM
SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array( $1 ),  $2 , true,  $3 )"
PL/pgSQL function "emaj_start_groups" line 15 at SQL statement
PL/pgSQL function "emaj_start_groups" line 5 at RETURN
 emaj_start_groups 
-------------------
                14
(1 row)

rollback;
-- impact of started group
select emaj.emaj_start_groups(array['myGroup1','myGroup2'],'Mark1',true);
 emaj_start_groups 
-------------------
                14
(1 row)

select group_name, group_state, group_nb_table, group_nb_sequence, group_comment 
  from emaj.emaj_group order by group_name, group_state;
    group_name    | group_state | group_nb_table | group_nb_sequence | group_comment 
------------------+-------------+----------------+-------------------+---------------
 myGroup1         | LOGGING     |              5 |                 1 | 
 myGroup2         | LOGGING     |              6 |                 2 | 
 phil's group#3", | LOGGING     |              2 |                 1 | 
(3 rows)

select mark_id, mark_group, regexp_replace(mark_name,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'), mark_global_seq, mark_state, mark_comment, mark_last_seq_hole_id, mark_last_sequence_id, mark_log_rows_before_next from emaj.emaj_mark order by mark_id;
 mark_id |    mark_group    | regexp_replace | mark_global_seq | mark_state | mark_comment | mark_last_seq_hole_id | mark_last_sequence_id | mark_log_rows_before_next 
---------+------------------+----------------+-----------------+------------+--------------+-----------------------+-----------------------+---------------------------
       6 | phil's group#3", | Mark3          |               0 | ACTIVE     |              |                     0 |                    35 |                          
      24 | myGroup1         | Mark1          |               0 | ACTIVE     |              |                     0 |                   169 |                          
      25 | myGroup2         | Mark1          |               0 | ACTIVE     |              |                     0 |                   169 |                          
(3 rows)

-----------------------------
-- emaj_stop_groups() tests
-----------------------------
-- NULL group names array
select emaj.emaj_stop_groups(NULL);
WARNING:  _check_group_names_array: No group name to process.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
 emaj_stop_groups 
------------------
                0
(1 row)

-- at least one group is unknown in emaj_group_def
select emaj.emaj_stop_groups('{""}');
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
WARNING:  _check_group_names_array: No group name to process.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
 emaj_stop_groups 
------------------
                0
(1 row)

select emaj.emaj_stop_groups('{"unknownGroup",""}');
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
ERROR:  _stop_group: group unknownGroup has not been created.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
select emaj.emaj_stop_groups('{"myGroup1","unknownGroup"}');
ERROR:  _stop_group: group unknownGroup has not been created.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
-- missing application table
begin;
  drop table mySchema2."myTbl3" cascade;
  select emaj.emaj_stop_groups(array['myGroup1','myGroup2']);
ERROR:  relation "myschema2.myTbl3" does not exist
CONTEXT:  SQL statement "LOCK TABLE myschema2."myTbl3" IN ACCESS EXCLUSIVE MODE"
PL/pgSQL function "_lock_groups" line 34 at EXECUTE statement
SQL statement "SELECT  emaj._lock_groups( $1 ,'', $2 )"
PL/pgSQL function "_stop_groups" line 47 at PERFORM
PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
rollback;
-- should be OK
select emaj.emaj_stop_groups(array['myGroup1','myGroup2'],'Global Stop at %');
 emaj_stop_groups 
------------------
               14
(1 row)

select mark_id, mark_group, regexp_replace(mark_name,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'), mark_global_seq, mark_state, mark_comment, mark_last_seq_hole_id, mark_last_sequence_id, mark_log_rows_before_next from emaj.emaj_mark order by mark_id;
 mark_id |    mark_group    |  regexp_replace  | mark_global_seq | mark_state | mark_comment | mark_last_seq_hole_id | mark_last_sequence_id | mark_log_rows_before_next 
---------+------------------+------------------+-----------------+------------+--------------+-----------------------+-----------------------+---------------------------
       6 | phil's group#3", | Mark3            |               0 | ACTIVE     |              |                     0 |                    35 |                          
      24 | myGroup1         | Mark1            |               0 | DELETED    |              |                     0 |                   169 |                         0
      25 | myGroup2         | Mark1            |               0 | DELETED    |              |                     0 |                   169 |                         0
      26 | myGroup1         | Global Stop at % |               0 | DELETED    |              |                     0 |                   183 |                          
      27 | myGroup2         | Global Stop at % |               0 | DELETED    |              |                     0 |                   183 |                          
(5 rows)

-- with warning about group names array content
select emaj.emaj_stop_groups(array['myGroup1',NULL,'myGroup2','','myGroup2','myGroup2','myGroup1']);
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup2.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup2.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup1.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
WARNING:  _stop_group: Group myGroup1 cannot be stopped because it is not in logging state.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
WARNING:  _stop_group: Group myGroup2 cannot be stopped because it is not in logging state.
CONTEXT:  PL/pgSQL function "emaj_stop_groups" line 7 at RETURN
 emaj_stop_groups 
------------------
                0
(1 row)

-- test end: stop the groups and reset history
truncate emaj.emaj_hist;
alter sequence emaj.emaj_hist_hist_id_seq restart 3000;

-- startStop.sql : test emaj_start_group(), emaj_start_groups(), emaj_stop_group() and emaj_stop_groups()functions
--
-- prepare groups
select emaj.emaj_create_group('myGroup1');
NOTICE:  table "myschema1_myTbl3_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj."myschema1_myTbl3_log""
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 82 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema1_myTbl3_emaj_log_trg" for table "myschema1.myTbl3" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS "myschema1_myTbl3_emaj_log_trg" ON myschema1."myTbl3""
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 147 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema1_myTbl3_emaj_trunc_trg" for table "myschema1.myTbl3" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS "myschema1_myTbl3_emaj_trunc_trg" ON myschema1."myTbl3""
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 155 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  table "myschema1_mytbl1_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema1_mytbl1_log"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 82 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema1_mytbl1_emaj_log_trg" for table "myschema1.mytbl1" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl1_emaj_log_trg ON myschema1.mytbl1"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 147 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema1_mytbl1_emaj_trunc_trg" for table "myschema1.mytbl1" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl1_emaj_trunc_trg ON myschema1.mytbl1"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 155 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  table "myschema1_mytbl4_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema1_mytbl4_log"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 82 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema1_mytbl4_emaj_log_trg" for table "myschema1.mytbl4" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl4_emaj_log_trg ON myschema1.mytbl4"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 147 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema1_mytbl4_emaj_trunc_trg" for table "myschema1.mytbl4" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl4_emaj_trunc_trg ON myschema1.mytbl4"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 155 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  table "myschema1_mytbl2_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema1_mytbl2_log"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 82 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema1_mytbl2_emaj_log_trg" for table "myschema1.mytbl2" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl2_emaj_log_trg ON myschema1.mytbl2"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 147 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema1_mytbl2_emaj_trunc_trg" for table "myschema1.mytbl2" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl2_emaj_trunc_trg ON myschema1.mytbl2"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 155 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
WARNING:  _create_tbl: table myschema1.mytbl2 has triggers (mytbl2trg). Verify the compatibility with emaj rollback operations (in particular if triggers update one or several other tables). Triggers may have to be manualy disabled before rollback.
CONTEXT:  SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  table "myschema1_mytbl2b_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema1_mytbl2b_log"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 82 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema1_mytbl2b_emaj_log_trg" for table "myschema1.mytbl2b" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl2b_emaj_log_trg ON myschema1.mytbl2b"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 147 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema1_mytbl2b_emaj_trunc_trg" for table "myschema1.mytbl2b" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema1_mytbl2b_emaj_trunc_trg ON myschema1.mytbl2b"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 155 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
 emaj_create_group 
-------------------
                 6
(1 row)

select emaj.emaj_create_group('myGroup2');
NOTICE:  table "myschema2_mytbl1_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema2_mytbl1_log"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 82 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_mytbl1_emaj_log_trg" for table "myschema2.mytbl1" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl1_emaj_log_trg ON myschema2.mytbl1"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 147 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_mytbl1_emaj_trunc_trg" for table "myschema2.mytbl1" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl1_emaj_trunc_trg ON myschema2.mytbl1"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 155 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  table "myschema2_mytbl2_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema2_mytbl2_log"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 82 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_mytbl2_emaj_log_trg" for table "myschema2.mytbl2" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl2_emaj_log_trg ON myschema2.mytbl2"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 147 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_mytbl2_emaj_trunc_trg" for table "myschema2.mytbl2" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl2_emaj_trunc_trg ON myschema2.mytbl2"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 155 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  table "myschema2_myTbl3_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj."myschema2_myTbl3_log""
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 82 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_myTbl3_emaj_log_trg" for table "myschema2.myTbl3" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS "myschema2_myTbl3_emaj_log_trg" ON myschema2."myTbl3""
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 147 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_myTbl3_emaj_trunc_trg" for table "myschema2.myTbl3" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS "myschema2_myTbl3_emaj_trunc_trg" ON myschema2."myTbl3""
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 155 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  table "myschema2_mytbl4_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema2_mytbl4_log"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 82 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_mytbl4_emaj_log_trg" for table "myschema2.mytbl4" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl4_emaj_log_trg ON myschema2.mytbl4"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 147 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_mytbl4_emaj_trunc_trg" for table "myschema2.mytbl4" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl4_emaj_trunc_trg ON myschema2.mytbl4"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 155 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  table "myschema2_mytbl5_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema2_mytbl5_log"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 82 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_mytbl5_emaj_log_trg" for table "myschema2.mytbl5" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl5_emaj_log_trg ON myschema2.mytbl5"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 147 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_mytbl5_emaj_trunc_trg" for table "myschema2.mytbl5" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl5_emaj_trunc_trg ON myschema2.mytbl5"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 155 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  table "myschema2_mytbl6_log" does not exist, skipping
CONTEXT:  SQL statement "DROP TABLE IF EXISTS emaj.myschema2_mytbl6_log"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 82 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_mytbl6_emaj_log_trg" for table "myschema2.mytbl6" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl6_emaj_log_trg ON myschema2.mytbl6"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 147 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
NOTICE:  trigger "myschema2_mytbl6_emaj_trunc_trg" for table "myschema2.mytbl6" does not exist, skipping
CONTEXT:  SQL statement "DROP TRIGGER IF EXISTS myschema2_mytbl6_emaj_trunc_trg ON myschema2.mytbl6"
PL/pgSQL function emaj._create_tbl(text,text,boolean) line 155 at EXECUTE statement
SQL statement "SELECT emaj._create_tbl(r_tblsq.grpdef_schema, r_tblsq.grpdef_tblseq, v_isRollbackable)"
PL/pgSQL function emaj.emaj_create_group(text,boolean) line 54 at PERFORM
PL/pgSQL function emaj.emaj_create_group(text) line 7 at RETURN
 emaj_create_group 
-------------------
                 8
(1 row)

INSERT INTO emaj.emaj_param (param_key, param_value_interval) VALUES ('history_retention','1 second'::interval);
select pg_sleep(1);
 pg_sleep 
----------
 
(1 row)

-----------------------------
-- emaj_start_group() tests
-----------------------------
-- group is unknown in emaj_group_def
select emaj.emaj_start_group(NULL,NULL);
ERROR:  _start_group: group <NULL> has not been created.
CONTEXT:  SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
select emaj.emaj_start_group('unknownGroup',NULL,NULL);
ERROR:  _start_group: group unknownGroup has not been created.
CONTEXT:  SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
-- reserved mark name
select emaj.emaj_start_group('myGroup1','EMAJ_LAST_MARK');
ERROR:  _check_new_mark: EMAJ_LAST_MARK is not an allowed name for a new mark.
CONTEXT:  SQL statement "SELECT emaj._check_new_mark(v_mark, v_groupNames)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 49 at SQL statement
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
-- should be OK
select emaj.emaj_start_group('myGroup1','Mark1');
 emaj_start_group 
------------------
                6
(1 row)

select emaj.emaj_start_group('myGroup2','Mark2',true);
 emaj_start_group 
------------------
                8
(1 row)

select emaj.emaj_start_group('phil''s group#3",','Mark3',false);
 emaj_start_group 
------------------
                3
(1 row)

select emaj.emaj_stop_group('myGroup1');
 emaj_stop_group 
-----------------
               6
(1 row)

select emaj.emaj_stop_group('myGroup2');
 emaj_stop_group 
-----------------
               8
(1 row)

-- should be OK, with a warning on fkey between tables from different groups
begin;
  alter table myschema2.myTbl4 drop constraint mytbl4_col44_fkey;
  alter table myschema2.myTbl4 add constraint mytbl4_col44_fkey 
    FOREIGN KEY (col44,col45) REFERENCES myschema1.myTbl1 (col11,col12) ON DELETE CASCADE ON UPDATE SET NULL;
  select emaj.emaj_start_group('myGroup2','Mark2');
WARNING:  _check_fk_groups: Foreign key mytbl4_col44_fkey, from table myschema2.mytbl4, references myschema1.mytbl1 that is outside groups (myGroup2).
CONTEXT:  SQL statement "SELECT emaj._check_fk_groups(array[v_groupNames[v_i]])"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 46 at PERFORM
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
 emaj_start_group 
------------------
                8
(1 row)

rollback;
-- start with generated mark name
select emaj.emaj_start_group('myGroup1','%abc%',true);
 emaj_start_group 
------------------
                6
(1 row)

select emaj.emaj_start_group('myGroup2','',false);
 emaj_start_group 
------------------
                8
(1 row)

-- group already started
select emaj.emaj_start_group('myGroup2','Mark3');
ERROR:  _start_group: The group myGroup2 cannot be started because it is not in idle state. An emaj_stop_group function must be previously executed.
CONTEXT:  SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
-- check how truncate reacts  - tables are empty anyway
-- ... for a rollbackable group (must be blocked in pg 8.4+)
truncate myschema1.mytbl1 cascade;
NOTICE:  truncate cascades to table "mytbl4"
ERROR:  emaj._forbid_truncate_fnct: TRUNCATE is not allowed while updates on this table (myschema1.mytbl1) are currently protected by E-Maj. Consider stopping the group before issuing a TRUNCATE.
-- ... for an audit_only group (must be logged in pg 8.4+)
truncate "phil's schema3"."phil's tbl1" cascade;
NOTICE:  truncate cascades to table "mytbl4"
NOTICE:  truncate cascades to table "myTbl2\"
select "phil's col11", "phil's col12", "phil\s col13", 
       emaj_verb, emaj_tuple, emaj_gid, emaj_user, emaj_user_ip 
  from emaj."phil's schema3_phil's tbl1_log";
 phil's col11 | phil's col12 | phil\s col13 | emaj_verb | emaj_tuple | emaj_gid | emaj_user | emaj_user_ip 
--------------+--------------+--------------+-----------+------------+----------+-----------+--------------
              |              |              | TRU       |            |        1 | postgres  | 
(1 row)

-- impact of started group
select group_name, group_state, group_nb_table, group_nb_sequence, group_comment 
  from emaj.emaj_group order by group_name, group_state;
    group_name    | group_state | group_nb_table | group_nb_sequence | group_comment 
------------------+-------------+----------------+-------------------+---------------
 myGroup1         | LOGGING     |              5 |                 1 | 
 myGroup2         | LOGGING     |              6 |                 2 | 
 phil's group#3", | LOGGING     |              2 |                 1 | 
(3 rows)

select mark_id, mark_group, regexp_replace(mark_name,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'), mark_global_seq, mark_state, mark_comment, mark_last_seq_hole_id, mark_last_sequence_id, mark_log_rows_before_next from emaj.emaj_mark order by mark_id;
 mark_id |    mark_group    | regexp_replace | mark_global_seq | mark_state | mark_comment | mark_last_seq_hole_id | mark_last_sequence_id | mark_log_rows_before_next 
---------+------------------+----------------+-----------------+------------+--------------+-----------------------+-----------------------+---------------------------
       5 | myGroup2         | Mark2          |               0 | DELETED    |              |                     0 |                    32 |                         0
       6 | phil's group#3", | Mark3          |               0 | ACTIVE     |              |                     0 |                    35 |                          
       8 | myGroup2         | STOP_%         |               0 | DELETED    |              |                     0 |                    49 |                          
      10 | myGroup1         | %abc%          |               0 | ACTIVE     |              |                     0 |                    63 |                          
      11 | myGroup2         | MARK_%         |               0 | ACTIVE     |              |                     0 |                    71 |                          
(5 rows)

-- check old events are deleted
select hist_function, hist_event, hist_object, regexp_replace(regexp_replace(hist_wording,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'),E'\\[.+\\]','(timestamp)','g'), hist_user from emaj.emaj_hist order by hist_id;
 hist_function  | hist_event |   hist_object    |         regexp_replace         | hist_user 
----------------+------------+------------------+--------------------------------+-----------
 START_GROUP    | BEGIN      | myGroup1         | With log reset                 | postgres
 LOCK_GROUP     | BEGIN      | myGroup1         |                                | postgres
 LOCK_GROUP     | END        | myGroup1         | 5 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup1         | Mark1                          | postgres
 SET_MARK_GROUP | END        | myGroup1         | Mark1                          | postgres
 START_GROUP    | END        | myGroup1         | 6 tables/sequences processed   | postgres
 START_GROUP    | BEGIN      | myGroup2         | With log reset                 | postgres
 LOCK_GROUP     | BEGIN      | myGroup2         |                                | postgres
 LOCK_GROUP     | END        | myGroup2         | 6 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup2         | Mark2                          | postgres
 SET_MARK_GROUP | END        | myGroup2         | Mark2                          | postgres
 START_GROUP    | END        | myGroup2         | 8 tables/sequences processed   | postgres
 START_GROUP    | BEGIN      | phil's group#3", | Without log reset              | postgres
 LOCK_GROUP     | BEGIN      | phil's group#3", |                                | postgres
 LOCK_GROUP     | END        | phil's group#3", | 2 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | phil's group#3", | Mark3                          | postgres
 SET_MARK_GROUP | END        | phil's group#3", | Mark3                          | postgres
 START_GROUP    | END        | phil's group#3", | 3 tables/sequences processed   | postgres
 STOP_GROUP     | BEGIN      | myGroup1         |                                | postgres
 LOCK_GROUP     | BEGIN      | myGroup1         |                                | postgres
 LOCK_GROUP     | END        | myGroup1         | 5 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup1         | STOP_%                         | postgres
 SET_MARK_GROUP | END        | myGroup1         | STOP_%                         | postgres
 STOP_GROUP     | END        | myGroup1         | 6 tables/sequences processed   | postgres
 STOP_GROUP     | BEGIN      | myGroup2         |                                | postgres
 LOCK_GROUP     | BEGIN      | myGroup2         |                                | postgres
 LOCK_GROUP     | END        | myGroup2         | 6 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup2         | STOP_%                         | postgres
 SET_MARK_GROUP | END        | myGroup2         | STOP_%                         | postgres
 STOP_GROUP     | END        | myGroup2         | 8 tables/sequences processed   | postgres
 START_GROUP    | BEGIN      | myGroup1         | With log reset                 | postgres
 LOCK_GROUP     | BEGIN      | myGroup1         |                                | postgres
 LOCK_GROUP     | END        | myGroup1         | 5 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup1         | %abc%                          | postgres
 SET_MARK_GROUP | END        | myGroup1         | %abc%                          | postgres
 START_GROUP    | END        | myGroup1         | 6 tables/sequences processed   | postgres
 START_GROUP    | BEGIN      | myGroup2         | Without log reset              | postgres
 LOCK_GROUP     | BEGIN      | myGroup2         |                                | postgres
 LOCK_GROUP     | END        | myGroup2         | 6 tables locked, 0 deadlock(s) | postgres
 SET_MARK_GROUP | BEGIN      | myGroup2         | MARK_%                         | postgres
 SET_MARK_GROUP | END        | myGroup2         | MARK_%                         | postgres
 START_GROUP    | END        | myGroup2         | 8 tables/sequences processed   | postgres
(42 rows)

delete from emaj.emaj_param where param_key = 'history_retention';
-----------------------------
-- emaj_stop_group() tests
-----------------------------
-- unknown group
select emaj.emaj_stop_group(NULL);
ERROR:  _stop_group: group <NULL> has not been created.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_group(text) line 8 at RETURN
select emaj.emaj_stop_group('unkownGroup');
ERROR:  _stop_group: group unkownGroup has not been created.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_group(text) line 8 at RETURN
-- should be OK
select emaj.emaj_stop_group('myGroup1');
 emaj_stop_group 
-----------------
               6
(1 row)

-- impact of stopped group
select group_name, group_state, group_nb_table, group_nb_sequence, group_comment 
  from emaj.emaj_group order by group_name, group_state;
    group_name    | group_state | group_nb_table | group_nb_sequence | group_comment 
------------------+-------------+----------------+-------------------+---------------
 myGroup1         | IDLE        |              5 |                 1 | 
 myGroup2         | LOGGING     |              6 |                 2 | 
 phil's group#3", | LOGGING     |              2 |                 1 | 
(3 rows)

select mark_id, mark_group, regexp_replace(mark_name,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'), mark_global_seq, mark_state, mark_comment, mark_last_seq_hole_id, mark_last_sequence_id, mark_log_rows_before_next from emaj.emaj_mark order by mark_id;
 mark_id |    mark_group    | regexp_replace | mark_global_seq | mark_state | mark_comment | mark_last_seq_hole_id | mark_last_sequence_id | mark_log_rows_before_next 
---------+------------------+----------------+-----------------+------------+--------------+-----------------------+-----------------------+---------------------------
       5 | myGroup2         | Mark2          |               0 | DELETED    |              |                     0 |                    32 |                         0
       6 | phil's group#3", | Mark3          |               0 | ACTIVE     |              |                     0 |                    35 |                          
       8 | myGroup2         | STOP_%         |               0 | DELETED    |              |                     0 |                    49 |                          
      10 | myGroup1         | %abc%          |               0 | DELETED    |              |                     0 |                    63 |                         0
      11 | myGroup2         | MARK_%         |               0 | ACTIVE     |              |                     0 |                    71 |                          
      12 | myGroup1         | STOP_%         |               2 | DELETED    |              |                     0 |                    77 |                          
(6 rows)

-- should be OK
select emaj.emaj_stop_group('myGroup2');
 emaj_stop_group 
-----------------
               8
(1 row)

-- warning, already stopped
select emaj.emaj_stop_group('myGroup2');
WARNING:  _stop_group: Group myGroup2 cannot be stopped because it is not in logging state.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_group(text) line 8 at RETURN
 emaj_stop_group 
-----------------
               0
(1 row)

-- start with auto-mark in a single transaction
begin transaction;
  select emaj.emaj_start_group('myGroup1',NULL);
 emaj_start_group 
------------------
                6
(1 row)

  select emaj.emaj_start_group('myGroup2','');
 emaj_start_group 
------------------
                8
(1 row)

commit;
select mark_id, mark_group, regexp_replace(mark_name,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'), mark_global_seq, mark_state, mark_comment, mark_last_seq_hole_id, mark_last_sequence_id, mark_log_rows_before_next from emaj.emaj_mark order by mark_id;
 mark_id |    mark_group    | regexp_replace | mark_global_seq | mark_state | mark_comment | mark_last_seq_hole_id | mark_last_sequence_id | mark_log_rows_before_next 
---------+------------------+----------------+-----------------+------------+--------------+-----------------------+-----------------------+---------------------------
       6 | phil's group#3", | Mark3          |               0 | ACTIVE     |              |                     0 |                    35 |                          
      14 | myGroup1         | MARK_%         |               2 | ACTIVE     |              |                     0 |                    91 |                          
      15 | myGroup2         | MARK_%         |               2 | ACTIVE     |              |                     0 |                    99 |                          
(3 rows)

begin transaction;
  select emaj.emaj_stop_group('myGroup1');
 emaj_stop_group 
-----------------
               6
(1 row)

  select emaj.emaj_stop_group('myGroup2');
 emaj_stop_group 
-----------------
               8
(1 row)

commit;
-- use of % in start mark name
select emaj.emaj_start_group('myGroup1','Foo%Bar');
 emaj_start_group 
------------------
                6
(1 row)

select mark_id, mark_group, regexp_replace(mark_name,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'), mark_global_seq, mark_state, mark_comment, mark_last_seq_hole_id, mark_last_sequence_id, mark_log_rows_before_next from emaj.emaj_mark order by mark_id;
 mark_id |    mark_group    | regexp_replace | mark_global_seq | mark_state | mark_comment | mark_last_seq_hole_id | mark_last_sequence_id | mark_log_rows_before_next 
---------+------------------+----------------+-----------------+------------+--------------+-----------------------+-----------------------+---------------------------
       6 | phil's group#3", | Mark3          |               0 | ACTIVE     |              |                     0 |                    35 |                          
      15 | myGroup2         | MARK_%         |               2 | DELETED    |              |                     0 |                    99 |                         0
      17 | myGroup2         | STOP_%         |               2 | DELETED    |              |                     0 |                   113 |                          
      18 | myGroup1         | Foo%Bar        |               2 | ACTIVE     |              |                     0 |                   119 |                          
(4 rows)

-----------------------------
-- test _verify_group function
-----------------------------
-- detection of an incompatible postgres version
begin;
  update emaj.emaj_group set group_pg_version = 
    case when substr(group_pg_version,1,3)='8.2' or substr(group_pg_version,1,3)='8.3' then '8.4RC1' 
         when substr(group_pg_version,1,3)>='8.3' then '8.2.0'
    end
    where group_name = 'myGroup2';
  select emaj.emaj_start_group('myGroup2','M1');
ERROR:  _verify_group: Checking tables group myGroup2: the group has been created with a non compatible postgresql version (8.2.0). It must be dropped and recreated.
CONTEXT:  SQL statement "SELECT 0 FROM emaj._verify_group(v_groupNames[v_i], true)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 37 at PERFORM
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
rollback;
-- detection of a missing application table
begin;
  drop table mySchema2."myTbl3" cascade;
  select emaj.emaj_start_group('myGroup2','M1');
ERROR:  _check_class: table or sequence myTbl3 doesn't exist.
CONTEXT:  PL/pgSQL function emaj._verify_group(text,boolean) line 53 at IF
SQL statement "SELECT 0 FROM emaj._verify_group(v_groupNames[v_i], true)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 37 at PERFORM
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
rollback;
-- detection of a missing log table
begin;
  drop table emaj.mySchema2_myTbl1_log;
  select emaj.emaj_start_group('myGroup2','M1');
ERROR:  _verify_group: Checking tables group myGroup2: log table myschema2_mytbl1_log not found.
CONTEXT:  SQL statement "SELECT 0 FROM emaj._verify_group(v_groupNames[v_i], true)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 37 at PERFORM
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
rollback;
-- detection of a missing log function
begin;
  drop function emaj.mySchema2_myTbl1_log_fnct() cascade;
NOTICE:  drop cascades to trigger myschema2_mytbl1_emaj_log_trg on table myschema2.mytbl1
  select emaj.emaj_start_group('myGroup2','M1');
ERROR:  _verify_group: Checking tables group myGroup2: log function myschema2_mytbl1_log_fnct not found.
CONTEXT:  SQL statement "SELECT 0 FROM emaj._verify_group(v_groupNames[v_i], true)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 37 at PERFORM
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
rollback;
-- detection of a missing rollback function
begin;
  drop function emaj.mySchema2_myTbl1_rlbk_fnct(bigint);
  select emaj.emaj_start_group('myGroup2','M1');
ERROR:  _verify_group: Checking tables group myGroup2: rollback function myschema2_mytbl1_rlbk_fnct not found.
CONTEXT:  SQL statement "SELECT 0 FROM emaj._verify_group(v_groupNames[v_i], true)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 37 at PERFORM
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
rollback;
-- detection of a missing log trigger
begin;
  drop trigger mySchema2_myTbl1_emaj_log_trg on mySchema2.myTbl1;
  select emaj.emaj_start_group('myGroup2','M1');
ERROR:  _verify_group: Checking tables group myGroup2: log trigger myschema2_mytbl1_emaj_log_trg not found.
CONTEXT:  SQL statement "SELECT 0 FROM emaj._verify_group(v_groupNames[v_i], true)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 37 at PERFORM
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
rollback;
-- detection of a missing truncate trigger (only exists with pg8.4+)
begin;
  drop trigger mySchema2_myTbl1_emaj_trunc_trg on mySchema2.myTbl1;
  select emaj.emaj_start_group('myGroup2','M1');
ERROR:  _verify_group: Checking tables group myGroup2: truncate trigger myschema2_mytbl1_emaj_trunc_trg not found.
CONTEXT:  SQL statement "SELECT 0 FROM emaj._verify_group(v_groupNames[v_i], true)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 37 at PERFORM
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
rollback;
-- detection of a discrepancies between application and log tables
begin;
  alter table mySchema2.myTbl1 drop column col13;
  select emaj.emaj_start_group('myGroup2','M1');
ERROR:  _verify_group: Checking tables group myGroup2: the structure of log table myschema2_mytbl1_log is not coherent with myschema2.mytbl1 (dropped or changed column?).
CONTEXT:  SQL statement "SELECT 0 FROM emaj._verify_group(v_groupNames[v_i], true)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 37 at PERFORM
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
rollback;
begin;
  alter table mySchema2.myTbl1 alter column col12 type text;
  select emaj.emaj_start_group('myGroup2','M1');
ERROR:  _verify_group: Checking tables group myGroup2: the structure of log table myschema2_mytbl1_log is not coherent with myschema2.mytbl1 (added or changed column?).
CONTEXT:  SQL statement "SELECT 0 FROM emaj._verify_group(v_groupNames[v_i], true)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 37 at PERFORM
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
rollback;
begin;
  alter table mySchema2.myTbl1 add column col99 smallint;
  select emaj.emaj_start_group('myGroup2','M1');
ERROR:  _verify_group: Checking tables group myGroup2: the structure of log table myschema2_mytbl1_log is not coherent with myschema2.mytbl1 (added or changed column?).
CONTEXT:  SQL statement "SELECT 0 FROM emaj._verify_group(v_groupNames[v_i], true)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 37 at PERFORM
SQL statement "SELECT emaj._start_groups(array[v_groupName], v_mark, false, v_resetLog)"
PL/pgSQL function emaj.emaj_start_group(text,text,boolean) line 17 at SQL statement
PL/pgSQL function emaj.emaj_start_group(text,text) line 6 at RETURN
rollback;
-----------------------------
-- emaj_start_groups() tests
-----------------------------
select emaj.emaj_stop_group('myGroup1');
 emaj_stop_group 
-----------------
               6
(1 row)

-- NULL group names array
select emaj.emaj_start_groups(NULL,NULL,NULL);
WARNING:  _check_group_names_array: No group name to process.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
 emaj_start_groups 
-------------------
                 0
(1 row)

-- at least one group is unknown in emaj_group_def
select emaj.emaj_start_groups('{""}',NULL);
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
PL/pgSQL function emaj.emaj_start_groups(text[],text) line 6 at RETURN
WARNING:  _check_group_names_array: No group name to process.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
PL/pgSQL function emaj.emaj_start_groups(text[],text) line 6 at RETURN
 emaj_start_groups 
-------------------
                 0
(1 row)

select emaj.emaj_start_groups('{"unknownGroup",""}',NULL,true);
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
ERROR:  _start_group: group unknownGroup has not been created.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
select emaj.emaj_start_groups('{"myGroup1","unknownGroup"}',NULL,false);
ERROR:  _start_group: group unknownGroup has not been created.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
-- reserved mark name
select emaj.emaj_start_groups('{"myGroup1"}','EMAJ_LAST_MARK');
ERROR:  _check_new_mark: EMAJ_LAST_MARK is not an allowed name for a new mark.
CONTEXT:  SQL statement "SELECT emaj._check_new_mark(v_mark, v_groupNames)"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 49 at SQL statement
SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
PL/pgSQL function emaj.emaj_start_groups(text[],text) line 6 at RETURN
-- second group is already started
select emaj.emaj_start_group('myGroup2','Mark1',true);
 emaj_start_group 
------------------
                8
(1 row)

select emaj.emaj_start_groups('{"myGroup1","myGroup2"}','Mark1',false);
ERROR:  _start_group: The group myGroup2 cannot be started because it is not in idle state. An emaj_stop_group function must be previously executed.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
select emaj.emaj_stop_group('myGroup2');
 emaj_stop_group 
-----------------
               8
(1 row)

-- should be OK, with a warning on fkey between tables from different groups and warning on group names array content
begin;
  alter table myschema2.myTbl4 drop constraint mytbl4_col44_fkey;
  alter table myschema2.myTbl4 add constraint mytbl4_col44_fkey 
    FOREIGN KEY (col44,col45) REFERENCES myschema1.myTbl1 (col11,col12) ON DELETE CASCADE ON UPDATE SET NULL;
  select emaj.emaj_start_groups(array['myGroup1',NULL,'myGroup2','','myGroup2','myGroup2','myGroup1'],'Mark1');
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
PL/pgSQL function emaj.emaj_start_groups(text[],text) line 6 at RETURN
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
PL/pgSQL function emaj.emaj_start_groups(text[],text) line 6 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup2.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
PL/pgSQL function emaj.emaj_start_groups(text[],text) line 6 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup2.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
PL/pgSQL function emaj.emaj_start_groups(text[],text) line 6 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup1.
CONTEXT:  SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
PL/pgSQL function emaj.emaj_start_groups(text[],text) line 6 at RETURN
WARNING:  _check_fk_groups: table myschema1.mytbl1 is referenced by foreign key mytbl4_col44_fkey from table myschema2.mytbl4 that is outside groups (myGroup1).
CONTEXT:  SQL statement "SELECT emaj._check_fk_groups(array[v_groupNames[v_i]])"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 46 at PERFORM
SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
PL/pgSQL function emaj.emaj_start_groups(text[],text) line 6 at RETURN
WARNING:  _check_fk_groups: Foreign key mytbl4_col44_fkey, from table myschema2.mytbl4, references myschema1.mytbl1 that is outside groups (myGroup2).
CONTEXT:  SQL statement "SELECT emaj._check_fk_groups(array[v_groupNames[v_i]])"
PL/pgSQL function emaj._start_groups(text[],text,boolean,boolean) line 46 at PERFORM
SQL statement "SELECT emaj._start_groups(emaj._check_group_names_array(v_groupNames), v_mark, true, v_resetLog)"
PL/pgSQL function emaj.emaj_start_groups(text[],text,boolean) line 16 at SQL statement
PL/pgSQL function emaj.emaj_start_groups(text[],text) line 6 at RETURN
 emaj_start_groups 
-------------------
                14
(1 row)

rollback;
-- impact of started group
select emaj.emaj_start_groups(array['myGroup1','myGroup2'],'Mark1',true);
 emaj_start_groups 
-------------------
                14
(1 row)

select group_name, group_state, group_nb_table, group_nb_sequence, group_comment 
  from emaj.emaj_group order by group_name, group_state;
    group_name    | group_state | group_nb_table | group_nb_sequence | group_comment 
------------------+-------------+----------------+-------------------+---------------
 myGroup1         | LOGGING     |              5 |                 1 | 
 myGroup2         | LOGGING     |              6 |                 2 | 
 phil's group#3", | LOGGING     |              2 |                 1 | 
(3 rows)

select mark_id, mark_group, regexp_replace(mark_name,E'\\d\\d\.\\d\\d\\.\\d\\d\\.\\d\\d\\d','%','g'), mark_global_seq, mark_state, mark_comment, mark_last_seq_hole_id, mark_last_sequence_id, mark_log_rows_before_next from emaj.emaj_mark order by mark_id;
 mark_id |    mark_group    | regexp_replace | mark_global_seq | mark_state | mark_comment | mark_last_seq_hole_id | mark_last_sequence_id | mark_log_rows_before_next 
---------+------------------+----------------+-----------------+------------+--------------+-----------------------+-----------------------+---------------------------
       6 | phil's group#3", | Mark3          |               0 | ACTIVE     |              |                     0 |                    35 |                          
      24 | myGroup1         | Mark1          |               2 | ACTIVE     |              |                     0 |                   169 |                          
      25 | myGroup2         | Mark1          |               2 | ACTIVE     |              |                     0 |                   169 |                          
(3 rows)

-----------------------------
-- emaj_stop_groups() tests
-----------------------------
-- NULL group names array
select emaj.emaj_stop_groups(NULL);
WARNING:  _check_group_names_array: No group name to process.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
 emaj_stop_groups 
------------------
                0
(1 row)

-- at least one group is unknown in emaj_group_def
select emaj.emaj_stop_groups('{""}');
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
WARNING:  _check_group_names_array: No group name to process.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
 emaj_stop_groups 
------------------
                0
(1 row)

select emaj.emaj_stop_groups('{"unknownGroup",""}');
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
ERROR:  _stop_group: group unknownGroup has not been created.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
select emaj.emaj_stop_groups('{"myGroup1","unknownGroup"}');
ERROR:  _stop_group: group unknownGroup has not been created.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
-- should be OK
select emaj.emaj_stop_groups(array['myGroup1','myGroup2']);
 emaj_stop_groups 
------------------
               14
(1 row)

-- with warning about group names array content
select emaj.emaj_stop_groups(array['myGroup1',NULL,'myGroup2','','myGroup2','myGroup2','myGroup1']);
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
WARNING:  _check_group_names_array: a group name is NULL or empty.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup2.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup2.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
WARNING:  _check_group_names_array: duplicate group name myGroup1.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
WARNING:  _stop_group: Group myGroup1 cannot be stopped because it is not in logging state.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
WARNING:  _stop_group: Group myGroup2 cannot be stopped because it is not in logging state.
CONTEXT:  PL/pgSQL function emaj.emaj_stop_groups(text[]) line 8 at RETURN
 emaj_stop_groups 
------------------
                0
(1 row)

-- test end: stop the groups and reset history
truncate emaj.emaj_hist;
alter sequence emaj.emaj_hist_hist_id_seq restart 3000;
